Pour ce level en recreant le psoeudo code on se retrouve avec une fonction v qui appelle plusieurs fonctions ğŸ‘
    - fgets
    - printf
    - fwrite
    - system

On vois que fgets vas rÃ©cuperer ce qui est entrÃ© dans l'entrÃ©e standard.
Puis on voit l'appel system qui lance un nouveau terminal et c'est bien cela qui nous intÃ©resse !

Le probleme Ã©tant que pour lancer la fonction system la condition est que m soit Ã©gal a 64 ce qui n'est pas le cas.

Il vas donc faloir trouver un moyen de modifier le m afin que l'on puisse rentrer dans la condition.

Pour ce faire, aprÃ¨s pas mal de recherches on peut voir quelque chose d'intÃ©ressant dans le man de printf : 
    Un code tel que printf(foo); indique souvent un bogue, car foo peut contenir un caractÃ¨re Â« % Â». Si foo vient 
    d'une saisie non sÃ©curisÃ©e il peut contenir Â« %n Â», ce qui autorise printf() Ã  Ã©crire dans la mÃ©moire, 
    et crÃ©e une faille de sÃ©curitÃ©.  

ainsi que :   
    n
        Le nombre de caractÃ¨res dÃ©jÃ  Ã©crits est stockÃ© dans l'entier indiquÃ© par l'argument pointeur de type int *. 
        Aucun argument n'est converti. (il prends en compte les 4 octets).
    et 

    On peut aussi prÃ©ciser explicitement quel argument prendre, en Ã©crivant, Ã  chaque conversion, "%m$" au lieu de " % ",
    et " *m$ " au lieu de " * ". L'entier dÃ©cimal m indique la position dans la liste d'arguments, l'indexation commenÃ§ant Ã  1.

On peut donc prÃ©ciser a printf l'ordre d'argument(%m$) dans la string et compter le nombre de caractÃ¨re d'une string(%n).

L'objectif est donc de crÃ©e une string de 64 caractÃ¨res et lui passer l'argument 'n' afin qu'il Ã©crive Ã  l'adresse de m le 
nombre de caractÃ¨res.

Pour cela il est necessaire que le printf prenne comme argument l'adresse de m.

printf prend le buffer en premier argument

On peut ecrire jusqu'a 512 caractÃ¨res dans le buffer.

On sait que printf vas chercher ses arguments sur la stack, et que notre buffer est aussi sur la stack :

    Donc on peut faire en sorte printf lise l'adresse de m en la mettant dans notre buffer.

Comme d'habitude il nous faut donc un script :

    Dans un premier temps l'adresse de m puis on ecrit 64 caractÃ¨res (60 caractÃ¨res (ex: 'A') et 4 autres pour spÃ©cifier 
    les arguments);

    On dÃ©fini qu'il s'agit du 4eme argument car :
        l'argument 1 correspond Ã  esp + 4 => 512, 
        l'argument 2 correspond Ã  esp + 8 => stdin,
        l'argument 3 correspond Ã  esp + 12 => ???,
        l'arguemnt 4 correspond Ã  esp + 16 => buffer, 
    
    On va donc placer l'adresse de m au debut de notre buffer et indiquer sa position avec l'attibut 4$.

    //0x804988c => adresse de m
    //AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA => chaine de 60 caractÃ¨res
    //%4$n => selectione l'argument nÂ°4 et ecrit le nombre de caractÃ¨res prÃ©cÃ©dement affichÃ©s Ã  l'adresse indiquÃ©e 
    dans le 4eme argument de printf(le 4Ã¨me argument de printf est l'adresse de m).

    python -c 'print "\x8c\x98\x04\x08" + "A" * 60 + "%4$n"'